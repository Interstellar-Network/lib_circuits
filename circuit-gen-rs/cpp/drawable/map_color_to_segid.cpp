// Copyright 2022 Nathan Prat

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "map_color_to_segid.h"

#include <absl/strings/str_split.h>
#include <absl/strings/strip.h>

namespace {

// The order MUST match with lib_garble/src/packmsg/packmsg_utils.cpp
// kMapDigitTo7Segs
// The colors MUSt match "data/7segs.png"
// Using an hardcoded map is (obviously) less flexible but it is way more
// robust.
// That way we have no dependency between the way we read/parse 7segs.png and
// the "ColorID" generated by Segments2Pixels.
// NOTE: NOT a map, but an array works fine for this:
// - 1c71c7 = Segment 0
// - 38e38e = Segment 1
// - etc
//
// clang-format off
static const std::vector<std::string> kMapColorToSegId =
  {   "1c71c7",
    "38e38e", "555555",
      "71c71c",
    "8e38e3", "aaaaaa",
      "c71c71"
  };
// clang-format on

uint8_t ByteHexToInt(std::string_view str) {
  if (str.length() > 2) {
    throw std::range_error("HexToInt : only for RGB color = 2 chars");
  }

  uint32_t result;
  if (!absl::SimpleHexAtoi(str, &result)) {
    throw std::range_error("HexToInt : not valid");
  }

  if (result > std::numeric_limits<uint8_t>::max()) {
    throw std::range_error("HexToInt : result does not fit on uint8_t");
  }
  return static_cast<uint8_t>(result);
}

}  // anonymous namespace

namespace interstellar::drawable {

ColorRGBA::ColorRGBA(u_int8_t r, u_int8_t g, u_int8_t b, u_int8_t a)
    : r(r), g(g), b(b), a(a) {}

ColorRGBA::ColorRGBA(std::string_view hex_string) {
  // - strip the leading "#"(if there is one)
  // - split 2 by 2 chars (b/c hex color is 2 chars)
  std::vector<std::string> hex_vect =
      absl::StrSplit(absl::StripPrefix(hex_string, "#"), absl::ByLength(2));

  r = ByteHexToInt(hex_vect.at(0));
  g = ByteHexToInt(hex_vect.at(1));
  b = ByteHexToInt(hex_vect.at(2));
  // alpha is optional
  if (hex_vect.size() == 4) {
    a = ByteHexToInt(hex_vect.at(3));
  } else {
    a = 255;
  }
}

absl::flat_hash_map<ColorRGBA, u_int32_t> GetMapColorToSegId() {
  absl::flat_hash_map<ColorRGBA, u_int32_t> map_color_seg_id;

  u_int32_t seg_id = 0;
  for (const auto &color_rgba_hex : kMapColorToSegId) {
    map_color_seg_id.emplace(ColorRGBA(color_rgba_hex), seg_id);

    seg_id++;
  }

  return map_color_seg_id;
}

}  // namespace interstellar::drawable
